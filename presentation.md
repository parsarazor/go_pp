# بررسی عمیق ورودی/خروجی استاندارد و پکیج `fmt` در Go

---

## فهرست مطالب

1. **جریان‌های استاندارد (Standard Streams)**
   - مفاهیم پایه
   - پیاده‌سازی در Go (`os.Stdin`, `os.Stdout`, `os.Stderr`)
2. **پکیج `fmt`**
   - مرور کلی
   - افعال فرمت‌دهی (Formatting Verbs)
   - توابع چاپ (Printing)
   - توابع اسکن (Scanning)
3. **اینترفیس‌های پیشرفته**
   - `Stringer`
   - `GoStringer`
   - `Formatter`
4. **نکات عملکردی و بهترین روش‌ها**

---

## ۱. جریان‌های استاندارد (Standard Streams)

در فلسفه یونیکس و سیستم‌عامل‌های مدرن، هر پروسه در هنگام اجرا سه جریان داده باز دارد:

1.  **Stdin (Standard Input):** ورودی استاندارد (معمولاً کیبورد).
2.  **Stdout (Standard Output):** خروجی استاندارد (معمولاً ترمینال/کنسول).
3.  **Stderr (Standard Error):** خطای استاندارد (برای لاگ‌ها و خطاها، جدا از خروجی اصلی).

### در زبان Go

در Go، این جریان‌ها از طریق پکیج `os` در دسترس هستند و نوع آن‌ها `*os.File` است.

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // نوشتن در Stdout
    os.Stdout.WriteString("این یک پیام در خروجی استاندارد است.\n")

    // نوشتن در Stderr
    os.Stderr.WriteString("این یک پیام خطا است.\n")

    // خواندن از Stdin
    // (نیاز به بافر دارد که در بخش‌های بعد می‌بینیم)
}
```

> **نکته:** از آنجا که `*os.File` اینترفیس‌های `io.Reader` و `io.Writer` را پیاده‌سازی می‌کند، می‌توانید از این جریان‌ها در هر تابعی که این اینترفیس‌ها را می‌پذیرد استفاده کنید.

---

## ۲. پکیج `fmt` - قلب فرمت‌دهی

پکیج `fmt` ورودی/خروجی فرمت‌دهی شده را با توابعی مشابه `printf` و `scanf` در زبان C پیاده‌سازی می‌کند.

### دسته‌بندی توابع

این پکیج توابع را در سه دسته اصلی ارائه می‌دهد:

1.  **Print/Scan:** کار با `os.Stdout` و `os.Stdin`.
    - `Print`, `Println`, `Printf`
    - `Scan`, `Scanln`, `Scanf`
2.  **Fprint/Fscan:** کار با هر `io.Writer` یا `io.Reader` (فایل‌ها، بافرها، اتصالات شبکه و ...).
    - `Fprint`, `Fprintln`, `Fprintf`
    - `Fscan`, `Fscanln`, `Fscanf`
3.  **Sprint/Sscan:** کار با رشته‌ها (String). خروجی را به جای چاپ، به صورت `string` برمی‌گرداند یا از یک `string` می‌خواند.
    - `Sprint`, `Sprintln`, `Sprintf`
    - `Sscan`, `Sscanln`, `Sscanf`

---

### افعال فرمت‌دهی (Formatting Verbs) - بخش مهم

قدرت اصلی `fmt` در "Verb"های آن است.

#### عمومی (General)

| Verb  | توضیحات                                    | مثال                              |
| :---- | :----------------------------------------- | :-------------------------------- |
| `%v`  | مقدار در فرمت پیش‌فرض                      | `Hello`                           |
| `%+v` | برای Structها، نام فیلدها را هم چاپ می‌کند | `{Name:Ali Age:20}`               |
| `%#v` | نمایش سینتکس Go (عالی برای دیباگ)          | `main.Person{Name:"Ali", Age:20}` |
| `%T`  | نمایش نوع متغیر                            | `main.Person`                     |

#### انواع داده خاص

- **Boolean:** `%t`
- **Integer:**
  - `%d`: مبنای ۱۰
  - `%b`: باینری
  - `%x`: هگزادسیمال
- **Float:**
  - `%f`: اعشاری ساده (مثلاً `10.55`)
  - `%e`: نماد علمی
  - `%.2f`: کنترل دقت اعشار (۲ رقم)
- **String:**
  - `%s`: رشته ساده
  - `%q`: رشته در کوتیشن (Quoted) - کاراکترهای کنترلی را اسکیپ می‌کند.
- **Pointer:**
  - `%p`: آدرس حافظه (هگز)

---

## ۳. اینترفیس‌های پیشرفته `fmt`

شما می‌توانید نحوه چاپ شدن ساختارهای داده (Structs) خود را کنترل کنید.

### `Stringer`

پرکاربردترین اینترفیس. اگر متد `String()` را پیاده‌سازی کنید، `fmt` از آن برای `%v` و `%s` استفاده می‌کند.

```go
type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    return fmt.Sprintf("%s (%d ساله)", p.Name, p.Age)
}
// fmt.Println(p) -> "Ali (20 ساله)"
```

### `GoStringer`

برای کنترل خروجی `%#v`. این برای لاگ‌های دیباگ بسیار مفید است تا تمام جزئیات داخلی را نشان دهید.

```go
func (p Person) GoString() string {
    return fmt.Sprintf("Person(n=%q, a=%d)", p.Name, p.Age)
}
```

### `Formatter`

پیچیده‌ترین و قدرتمندترین اینترفیس. متد `Format(f State, c rune)` به شما اجازه می‌دهد بر اساس Verb استفاده شده (مثلاً اینکه کاربر `%s` زده یا `%v` یا `%x`) خروجی متفاوتی تولید کنید.

---

## ۴. ورودی (Scanning) و مدیریت خطا

توابع `Scan` فضاها (Space) را به عنوان جداکننده در نظر می‌گیرند (به جز `Scanln` که با خط جدید متوقف می‌شود).

```go
var name string
var age int
// منتظر می‌ماند تا کاربر ورودی دهد: "Ali 25"
n, err := fmt.Scan(&name, &age)
if err != nil {
    fmt.Println("خطا در خواندن:", err)
}
fmt.Printf("خوانده شد: %d مورد. نام: %s, سن: %d\n", n, name, age)
```

> **نکته مهم:** `fmt.Scan` برای ورودی‌های ساده خوب است، اما برای ورودی‌های پیچیده یا خواندن خط به خط، استفاده از `bufio.Scanner` توصیه می‌شود زیرا کنترل بیشتری روی بافر و جداکننده‌ها دارد.

---

## ۵. نکات پایانی

1.  **Fmt vs Log:** برای لاگ کردن خطاهای سیستم، معمولاً از پکیج `log` استفاده می‌شود نه `fmt`. پکیج `log` به صورت پیش‌فرض در `Stderr` می‌نویسد و تاریخ/زمان اضافه می‌کند.
2.  **Buffering:** توابع `fmt` بافر شده نیستند. اگر هزاران بار `fmt.Print` را صدا بزنید، هزاران System Call خواهید داشت. در این موارد، از `bufio.Writer` استفاده کنید و در نهایت `Flush` کنید.
3.  **Errors:** همیشه خروجی توابع `Scan` را چک کنید. ورودی کاربر غیرقابل اعتماد است.

---

_تهیه شده توسط دستیار هوشمند شما_
