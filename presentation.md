# پشت پرده جریان‌های استاندارد و جادوی `fmt` در Go

## مقدمه: فراتر از سطح

ما هر روز از `fmt.Println` استفاده می‌کنیم، اما واقعاً چه اتفاقی در زیر کاپوت می‌افتد؟ این ارائه به بررسی عمیق تاریخچه، معماری سیستم‌عامل و پیاده‌سازی داخلی Go می‌پردازد.

## فصل اول: ریشه‌های تاریخی و فلسفه یونیکس

### "همه چیز یک فایل است" (Everything is a File)
در دهه ۱۹۷۰، کن تامپسون و دنیس ریچی در آزمایشگاه‌های بل، یونیکس را با یک ایده انقلابی ساختند: **انتزاع یکپارچه**.
کیبورد شما، مانیتور، پرینتر، و حتی اتصالات شبکه، همگی به عنوان "فایل" مدل‌سازی شدند. این یعنی شما با همان توابعی که یک فایل متنی را می‌خوانید (`read`, `write`)، می‌توانید با سخت‌افزار صحبت کنید.

### تولد جریان‌های استاندارد (Standard Streams)
قبل از یونیکس، برنامه‌ها مستقیماً به دستگاه‌های خاص متصل می‌شدند. یونیکس مفهوم **File Descriptor (FD)** را معرفی کرد. هر پروسه هنگام تولد، سه FD دریافت می‌کند که به جدول فایل‌های باز در کرنل اشاره دارند:

1.  **FD 0 (Stdin):** ورودی استاندارد.
2.  **FD 1 (Stdout):** خروجی استاندارد.
3.  **FD 2 (Stderr):** خطای استاندارد.

> **چرا Stderr جدا شد؟**
> در نسخه‌های اولیه، فقط stdout وجود داشت. اما وقتی خروجی برنامه به یک فایل پایپ می‌شد (مثلاً `ls > file.txt`)، پیام‌های خطا هم داخل فایل می‌رفتند و کاربر آن‌ها را نمی‌دید. Stderr متولد شد تا یک کانال "خارج از باند" (Out-of-band) برای خطاها باشد که حتی هنگام ریدایرکت شدن stdout، همچنان روی صفحه نمایش داده شود.

---

## فصل دوم: معماری سیستم‌عامل و Go

### File Descriptors در عمل
وقتی شما در Go می‌نویسید `os.Stdout`، در واقع یک ساختار `os.File` دارید که یک عدد صحیح (FD) را نگه می‌دارد.

```go
// در سورس کد Go (os/file.go)
var (
    Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
    Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
    Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
)
```

### پایپ‌ها (Pipes) و ریدایرکشن
وقتی در شل می‌نویسید `app1 | app2`:
1.  شل دو پروسه می‌سازد.
2.  یک "لوله" (Pipe) در کرنل ایجاد می‌کند (یک بافر حافظه).
3.  FD 1 (Stdout) برای `app1` را به ورودی لوله وصل می‌کند.
4.  FD 0 (Stdin) برای `app2` را به خروجی لوله وصل می‌کند.
5.  حالا بایت‌ها مستقیماً از حافظه `app1` به حافظه `app2` جریان می‌یابند، بدون دخالت دیسک!

---

## فصل سوم: کالبدشکافی پکیج `fmt`

چگونه `fmt.Println(myStruct)` می‌فهمد که چگونه ساختار شما را چاپ کند؟ پاسخ در **Reflection** است.

### جادوی `interface{}` و `reflect`
توابع `fmt` آرگومان‌های خود را به صورت `...interface{}` می‌پذیرند.
1.  وقتی متغیری را پاس می‌دهید، Go نوع و مقدار آن را در یک اینترفیس بسته‌بندی می‌کند.
2.  پکیج `fmt` از پکیج `reflect` استفاده می‌کند تا در زمان اجرا (Runtime) نوع متغیر را بررسی کند.

```go
// شبه‌کد ساده‌سازی شده از داخل fmt
func (p *pp) printArg(arg interface{}) {
    // 1. Check for interfaces
    if formatter, ok := arg.(Formatter); ok {
        formatter.Format(p, verb)
        return
    }
    if stringer, ok := arg.(Stringer); ok {
        p.printString(stringer.String())
        return
    }

    // 2. Fallback to reflection
    val := reflect.ValueOf(arg)
    switch val.Kind() {
    case reflect.Int:
        p.fmtInteger(val.Int(), 10)
    case reflect.Struct:
        p.printStruct(val)
    // ...
    }
}
```

### ماشین حالت (State Machine)
پکیج `fmt` یک ماشین حالت داخلی دارد (struct `pp`) که بافر خروجی، فلگ‌ها (مثل `+` یا `#`) و عرض فیلد را نگه می‌دارد. این شیء `pp` برای کارایی بالا در یک `sync.Pool` ذخیره می‌شود تا از تخصیص حافظه زیاد (Allocation) جلوگیری شود.

---

## فصل چهارم: تکنیک‌های پیشرفته و خلاقانه

### ۱. مولتی‌پلکس کردن خروجی (MultiWriter)
می‌خواهید خروجی هم در ترمینال چاپ شود و هم در فایل لاگ؟

```go
logFile, _ := os.Create("app.log")
// ترکیب دو رایتر
multi := io.MultiWriter(os.Stdout, logFile)
fmt.Fprintln(multi, "این پیام هم دیده می‌شود و هم ذخیره!")
```

### ۲. دزدیدن خروجی (Hijacking Stdout)
می‌توانید `os.Stdout` را تغییر دهید تا خروجی کدهای دیگر (حتی کتابخانه‌های ثالث) را بگیرید!

```go
original := os.Stdout
r, w, _ := os.Pipe()
os.Stdout = w // تغییر مسیر جهانی

fmt.Println("این پیام به پایپ می‌رود نه ترمینال")

w.Close()
os.Stdout = original // بازگرداندن
// حالا می‌توانید از r بخوانید
```

### ۳. اسکنر هوشمند (Scanner Split Functions)
`bufio.Scanner` فقط برای خط به خط خواندن نیست. می‌توانید تابع `Split` خود را بنویسید تا استریم را بر اساس کلمات، بایت‌های خاص، یا پروتکل‌های باینری پارس کنید.

```go
scanner := bufio.NewScanner(os.Stdin)
// اسکن کلمه به کلمه
scanner.Split(bufio.ScanWords)
for scanner.Scan() {
    fmt.Println("کلمه:", scanner.Text())
}
```

---

## نتیجه‌گیری

جریان‌های استاندارد و پکیج `fmt` فقط ابزارهای ساده چاپ نیستند؛ آن‌ها دروازه‌ای به معماری یونیکس و سیستم تایپ پویای Go هستند. درک عمیق آن‌ها به شما قدرت کنترل کامل بر ورودی و خروجی برنامه‌هایتان را می‌دهد.
